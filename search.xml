<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[如何在java8中对HashMap排序？]]></title>
      <url>/2017/10/22/%E6%B5%8B%E8%AF%95%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[<div id="post-content" class="post-content" itemprop="articleBody"><br>        <p class="post-tags"><a href="/tag/java8">java8</a><a href="/tag/%E6%8E%92%E5%BA%8F">排序</a><a href="/tag/HashMap">HashMap</a></p><br>        <p>随着java8的发布、使得java语言也具有了函数式编程的功能，那我们如何在日常的开发中利用好这一个特性呢？例如我们如何使用java8中的lambda表达式和Stream API对Map进行排序？那就是这篇文章要和大家探讨的问题。首先我要向大家介绍如何通过java8的lambda和Stream Api对Map进行排序。其次还要和大家分享java8中的一些核心特性。<br>顺便说一句、并不全是因为lambda表达式和Stream使得java编程变得有趣，还有一些新的API被加入到已经存在的接口当中，例如 Comparator, Map.Entry  才使得java编程变得越来越有趣。</p><br><p>通过在接口上引入非抽象方法，例如默认方法和静态方法，可以实现对现有接口的扩展。</p><br><p>使用这种方式，可以将新方法添加到现有的Java接口中，而Java API设计人员已经利用这些方法在流行的现有接口中添加了急需的多中方法。</p><br><p>其中一个最好的例子是java.util.Comparator。比较器接口现在已经有了comparing()和 thenComparing()方法通过此方法可以链多个比较器进行了比较，这使得比较多个字段比较容易。</p><br><p>java.util.Map类的内部静态类Map.Entry同样也不甘落后，它有两个额外的方法comparingByKey() 和comparingByValue()，这两个方法分别通过键和值对Map进行排序。同时这两个方法也可以和Stream中的Sorted方法一起对HashMap进行值排序。</p><br><p><u><strong>Sorting Map by values on Increasing order</strong></u><br>你可以在java8中使用java.util.stream.Stream类中的sorted()方法对Map(HashMap,LinkedHashMap或者TreeMap)排序.那意味着接受一个Comparator来作为排序器来定义排序的规则.如果你想通过值进行排序、那么你应该使用Map.Entry中的comparingByValue()方法，这个方法是java8为了提升排序的简洁性而新增加的方法.</p><br><pre><code class="language-java hljs">ItemToPrice.entrySet()<br>.stream()<br>.sorted(Map.Entry.&lt;String, Integer&gt;comparingByValue())<br>.forEach(System.out::println);<br></code></pre><br><p>但是如果你需要的是一个Map而不仅仅是将结果输出到控制台,那么你可以将结果使用Stream和Collectors类中的collect()方法来收集结果.如下所示:</p><br><pre><code class="language-java hljs"><span class="hljs-comment">// now, let’s collect the sorted entries in </span><br>Map Map&lt;String, Integer&gt; sortedByPrice = ItemToPrice.entrySet() .stream() .<br>sorted(Map.Entry.&lt;String, Integer&gt;comparingByValue()) .<br>collect(Collectors.toMap(e -&gt; e.getKey(),e -&gt; e.getValue()));<br></code></pre><br><p>上面代码不能正确的排序，因为当你在Map中收集结果结果的时候、排序的顺序已经被打乱了，所以你需要使用LinkedHashMap来保存序列；</p><br><pre><code class="language-java hljs">Map&lt;String, Integer&gt; sortedByValue = ItemToPrice.entrySet() .stream() .<br>sorted(Map.Entry.&lt;String, Integer&gt;comparingByValue()) .<br>collect(toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt;<br>e1, LinkedHashMap::<span class="hljs-keyword">new</span>))<br><br></code></pre><br><p>以上才是在java8中正确的排序方式。因为我们使用LinkedHashMap来存储entries对象.这也是一个在java8中使用构造器引用的例子.</p><br><p><u><strong>Sorting Map by values on decreasing Order</strong></u><br>为了通过降序对Map进行排序，我们只需要传递一个按照反向序列的Comparator.你可以使用java.util.Comparator中的reversed()方法.这个方法同样也是java8新加入Comparator类中的.</p><br><pre><code class="language-java hljs">Map&lt;String, Integer&gt; sortedByValueDesc = ItemToPrice.entrySet() .stream() .<br>sorted(Map.Entry.&lt;String, Integer&gt;comparingByValue().reversed()) .<br>collect(toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt;<br>e1, LinkedHashMap::<span class="hljs-keyword">new</span>));<br><br></code></pre><br><p>这里的重点是reversed()方法的使用.其他的代码和之前的代码是一样的.首先你从Map中得到一个   entry set,然后得到一个Stream,使用sorted()方法对元素进行排序,同样sort()需要comparator.</p><br><p>你提供了一个通过值进行排序的Comparator,然后调用reverse()方法倒置它，这样所有的元素就会按照倒叙进行排列.最后在你收集元素到Map过程中，你要求Collector使用LinkedHashMap来收集元素,注意这里使用了方法引用，与方法引用不同的是方法引用是通过名称来调用方法、而这里使用new关键字而已.</p><br><p><u><strong>Important points to Remember</strong></u></p><br><p>总之,在我们对Map进行排序时候，有一些观点或许是我们需要注意的,对于我们正确的排序HashMap和HashTable同样很重要.</p><br><ol><br><li>使用LinkedHashMap来保持原来排序结果的完整性</li><br><li>为了更好的可读性尽量使用静态导入例如 static import Map.Entry</li><br><li>使用内部类Map.Entry中新加入的comparingByKey()和comparingByValue() 来简化排序</li><br><li>使用reversed()方法降序排序</li><br><li>使用foreach输出Map</li><br><li>使用Collectors收集结果到Map当中,但是始终使用LinkedHashMap因为它保持了原始的排序顺序</li><br></ol><br><p>你可以继续学习java8中的其他特性，给大家推荐一本书</p><br><div class="separator" style="clear: both; text-align: center;"><br><a href="http://aax-us-east.amazon-adsystem.com/x/c/QtqdUhT6eHChVaiw5_26ON0AAAFe8kxdcwEAAAFKAQl0Vq8/http://www.amazon.com/Java-SE8-Really-Impatient-Course/dp/0321927761/ref=as_at?creativeASIN=0321927761&amp;linkCode=w61&amp;imprToken=wmvN5f2LUNVzpx3CpDy-2w&amp;slotNum=3&amp;tag=javamysqlanta-20" rel="nofollow" target="_blank" style="margin-left: 1em; margin-right: 1em;" data-amzn-asin="0321927761"><img border="0" data-original-height="649" data-original-width="501" height="320" src="https://4.bp.blogspot.com/-SHiZYPAgvNw/WW4nvFlSyhI/AAAAAAAAJEk/aO6Zgi2tRtY9ZUaEB5AJBQ4xVD8t9HwgQCLcBGAs/s320/Java%2BSE%2B8%2Bfor%2BReally%2BImpatient%2BBest%2BBook.jpg" width="247"></a></div><br><p><strong><u># # Java Program to Sort the Map by Values in JDK 8</u></strong><br>这里我列出了在java8中如何利用lambda表达式对HashMap进行值排序的完整示例,使用到了方法引用,Map.Entry的comparingByValue方法.这些方法的引入使得排序更加简单明了.</p><br><pre><code class="language-java hljs"><span class="hljs-comment">/<em> </em> To change this license header, choose License Headers in Project Properties. <em> To change this template file, choose Tools | Templates </em> and open the template in the editor. <em>/</em></span><br><span class="hljs-keyword">package</span> test;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.LinkedHashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.stream.Collectors.;<br><br><span class="hljs-comment">/<strong><br> <em> </em> <span class="hljs-doctag">@author</span> Javin Paul<br> */</strong></span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortingMapByValueInJava8</span> </span>{<br>    <span class="hljs-comment">/<br>     <em> <span class="hljs-doctag">@param</span> args </em> the command line arguments<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        Map&lt;String, Integer&gt; ItemToPrice = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        ItemToPrice.put(<span class="hljs-string">“Sony Braiva”</span>, <span class="hljs-number">1000</span>);<br>        ItemToPrice.put(<span class="hljs-string">“Apple iPhone 6S”</span>, <span class="hljs-number">1200</span>);<br>        ItemToPrice.put(<span class="hljs-string">“HP Laptop”</span>, <span class="hljs-number">700</span>);<br>        ItemToPrice.put(<span class="hljs-string">“Acer HD Monitor”</span>, <span class="hljs-number">139</span>);<br>        ItemToPrice.put(<span class="hljs-string">“Samsung Galaxy”</span>, <span class="hljs-number">800</span>);<br><br>        System.out.println(<span class="hljs-string">“unsorted Map: “</span> + ItemToPrice);<br><br>        ItemToPrice.entrySet().stream()<br>                .sorted(Map.Entry.&lt;String, Integer&gt; comparingByValue())<br>                .forEach(System.out::println);<br>        Map&lt;String, Integer&gt; sortedByPrice = ItemToPrice.entrySet().stream() .sorted(Map.Entry.&lt;String, Integer&gt; comparingByValue()) .<br>                collect(Collectors.toMap(e -&gt; e.getKey(), e -&gt; e.getValue()));<br><br>        System.out.println(<span class="hljs-string">“Map incorrectly sorted by value in ascending order: “</span> + sortedByPrice);<br><br><br>        Map&lt;String, Integer&gt; sortedByValue = ItemToPrice .entrySet() .stream() .sorted(Map.Entry.&lt;String, Integer&gt; comparingByValue()) .<br>                collect( toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e1, LinkedHashMap::<span class="hljs-keyword">new</span>));<br><br>        System.out.println(<span class="hljs-string">“Map sorted by value in increasing order: “</span> + sortedByValue);<br><br>        Map&lt;String, Integer&gt; sortedByValueDesc = ItemToPrice .entrySet() .stream() .sorted(Map.Entry.&lt;String, Integer&gt; comparingByValue().reversed()) .<br>                collect( toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e1, LinkedHashMap::<span class="hljs-keyword">new</span>));<br>        System.out.println(<span class="hljs-string">“Map sorted by value in descending order: “</span> + sortedByValueDesc);<br><br><br>        ItemToPrice.entrySet().<br>                stream().<br>                sorted(<br>                        Map.Entry.&lt;String,Integer&gt;comparingByValue()<br>                                .reversed()<br>                ) .collect(toMap(<br>                        Map.Entry::getKey,Map.Entry::getValue,(e1,d2)-&gt; e1,LinkedHashMap::<span class="hljs-keyword">new</span>));<br><br><br>    }<br>}<br>Output unsorted Map: {Samsung Galaxy=<span class="hljs-number">800</span>, HP Laptop=<span class="hljs-number">700</span>, Sony Braiva=<span class="hljs-number">1000</span>, Acer HD Monitor=<span class="hljs-number">139</span>, Apple iPhone <span class="hljs-number">6</span>S=<span class="hljs-number">1200</span>}<br>        Acer HD Monitor=<span class="hljs-number">139</span><br>        HP Laptop=<span class="hljs-number">700</span><br>        Samsung Galaxy=<span class="hljs-number">800</span><br>        Sony Braiva=<span class="hljs-number">1000</span><br>        Apple iPhone <span class="hljs-number">6</span>S=<span class="hljs-number">1200</span><br>        Map incorrectly sorted by value in ascending order: {Samsung Galaxy=<span class="hljs-number">800</span>, HP Laptop=<span class="hljs-number">700</span>, Sony Braiva=<span class="hljs-number">1000</span>,<br>        Acer HD Monitor=<span class="hljs-number">139</span>, Apple iPhone <span class="hljs-number">6</span>S=<span class="hljs-number">1200</span>} Map sorted by value in increasing order: {Acer HD Monitor=<span class="hljs-number">139</span>,<br>        HP Laptop=<span class="hljs-number">700</span>, Samsung Galaxy=<span class="hljs-number">800</span>, Sony Braiva=<span class="hljs-number">1000</span>, Apple iPhone <span class="hljs-number">6</span>S=<span class="hljs-number">1200</span>}<br>        Map sorted by value in descending order: {Apple iPhone <span class="hljs-number">6</span>S=<span class="hljs-number">1200</span>, Sony Braiva=<span class="hljs-number">1000</span>, Samsung Galaxy=<span class="hljs-number">800</span>,<br>        HP Laptop=<span class="hljs-number">700</span>, Acer HD Monitor=<span class="hljs-number">139</span>}<br><br></code></pre><br><p>从上面的代码可以看出整数map通过值进行排序.我们打印出所有已经排序好的元素对象,如上面Acer HD Monitor 是第一个打印出来的因为他是最便宜的,并且Apple iPhone是最后一个打印出来的，因为他是最贵的.</p><br><p>在第二个例子中,虽然我们像之前那样排序，但是结果并不是我们所期望的,那是因为我们在收集collect结果的时候并没有保持他们的排序顺序.我们应该使用LinkedHashMap,LinkedHashMap能保证元素按照插入顺序排列在集合中.</p><br><p>在上面第三个和第四个例子中,我们改正了我们的错误,我们使用LinkedHashMap来手机排序好的数据流,因此元素得以正确的排序.最后一个例子我们按照降序排列.第一个是Apple ,并且Acer是最后一个.</p><br><p>以下是在java8中用一行代码对HashMap通过值进行排序.</p><br><pre><code class="language-java hljs">ItemToPrice.entrySet().<br>                stream().<br>                sorted(<br>                        Map.Entry.&lt;String,Integer&gt;comparingByValue()<br>                                .reversed()<br>                ) .collect(toMap(<br>                        Map.Entry::getKey,Map.Entry::getValue,(e1,d2)-&gt; e1,LinkedHashMap::<span class="hljs-keyword">new</span>));<br></code></pre><br><p>以上便是在java8中所有有关如何通过值排序Map的内容.你可以使用这项技术排序任何Map的实现类，例如HashMap,Hashtable,ConcurrentHashMap,TreeMap等等,如果你不需要打印或者执行任何操作,你仅仅是想排序原来的Map，那么确认使用collect()方法将排序好的流导入到Map中.并且确认使用LinkedHashMap去收集元素.否则排序结果会被丢失.</p><br><p>除此之外,你也可以进一步深入阅读以下文章.</p><br><ol><br><li><br><p><a href="http://www.shareasale.com/m-pr.cfm?merchantID=53701&amp;userID=880419&amp;productID=546412549" target="_blank" rel="external">What’s New in Java 8</a></p><br></li><br><li><br><p><a href="http://aax-us-east.amazon-adsystem.com/x/c/QtqdUhT6eHChVaiw5_26ON0AAAFe8kxdcwEAAAFKAQl0Vq8/http://www.amazon.com/Java-SE8-Really-Impatient-Course/dp/0321927761/ref=as_at?creativeASIN=0321927761&amp;linkCode=w61&amp;imprToken=wmvN5f2LUNVzpx3CpDy-2w&amp;slotNum=4&amp;tag=javamysqlanta-20" target="_blank" rel="external">Java SE 8 for Really Impatient</a></p><br></li><br></ol><br><br>    </div>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[跟上Java8 - Stream API快速入门]]></title>
      <url>/2017/10/22/testpic/</url>
      <content type="html"><![CDATA[<div id="post-content" class="post-content" itemprop="articleBody"><br><br><br><br><br><br></div><br><pre><code class="hljs xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“top-gap-big”</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>在前面我们简单介绍了<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>lambda<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>表达式，Java8旨在帮助程序员写出更好的代码，<br></code></pre><br><p>其对核心类库的改进也是关键的一部分，<code>Stream</code>是Java8种处理集合的抽象概念，<br>它可以指定你希望对集合的操作，但是执行操作的时间交给具体实现来决定。</p><p></p><br><a id="more"></a><br><h2>为什么需要Stream?</h2><br><p>Java语言中集合是使用最多的API，几乎每个Java程序都会用到集合操作，<br>这里的Stream和IO中的Stream不同，它提供了对集合操作的增强，极大的提高了操作集合对象的便利性。</p><br><p>集合对于大多数编程任务而言都是基本的，为了解释集合是怎么工作，我们想象一下当下最火的外卖APP，<br>当我们点菜的时候需要按照<strong>距离</strong>、<strong>价格</strong>、<strong>销量</strong>等进行排序后筛选出自己满意的菜品。<br>你可能想选择距离自己最近的一家店铺点菜，尽管用集合可以完成这件事，但集合的操作远远算不上完美。</p><br><p>假如让你编写上面示例中的代码，你可能会写出如下：</p><br><pre><code class="language-java hljs"><span class="hljs-comment"><span class="hljs-comment">// 店铺属性</span></span><br><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Property</span></span></span><span class="hljs-class"> </span></span>{<br>    String  name;<br>    <span class="hljs-comment"><span class="hljs-comment">// 距离，单位:米</span></span><br>    Integer distance;<br>    <span class="hljs-comment"><span class="hljs-comment">// 销量，月售</span></span><br>    Integer sales;<br>    <span class="hljs-comment"><span class="hljs-comment">// 价格，这里简单起见就写一个级别代表价格段</span></span><br>    Integer priceLevel;<br><pre><code>&lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-function”</span>&gt;&lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-keyword”</span>&gt;<span class="hljs-keyword">public</span>&lt;/span&gt; &lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-title”</span>&gt;Property&lt;/span&gt;&lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-params”</span>&gt;(String name, &lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-keyword”</span>&gt;<span class="hljs-keyword">int</span>&lt;/span&gt; distance, &lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-keyword”</span>&gt;<span class="hljs-keyword">int</span>&lt;/span&gt; sales, &lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-keyword”</span>&gt;<span class="hljs-keyword">int</span>&lt;/span&gt; priceLevel)&lt;/span&gt; &lt;/span&gt;{<br>    &lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-keyword”</span>&gt;<span class="hljs-keyword">this</span>&lt;/span&gt;.name = name;<br>    &lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-keyword”</span>&gt;<span class="hljs-keyword">this</span>&lt;/span&gt;.distance = distance;<br>    &lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-keyword”</span>&gt;<span class="hljs-keyword">this</span>&lt;/span&gt;.sales = sales;<br>    &lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-keyword”</span>&gt;<span class="hljs-keyword">this</span>&lt;/span&gt;.priceLevel = priceLevel;<br>}<br>&lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-comment”</span>&gt;<span class="hljs-comment">// getter setter 省略&lt;/span&gt;</span><br></code></pre><br></code><p><code class="language-java hljs">}<br></code></p></pre><p></p><br><p>我想要筛选距离我最近的店铺，你可能会写下这样的代码：</p><br><pre><code class="language-java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{<br>    Property p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Property(<span class="hljs-string"><span class="hljs-string">“叫了个鸡”</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);<br>    Property p2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Property(<span class="hljs-string"><span class="hljs-string">“张三丰饺子馆”</span></span>, <span class="hljs-number"><span class="hljs-number">2300</span></span>, <span class="hljs-number"><span class="hljs-number">1500</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);<br>    Property p3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Property(<span class="hljs-string"><span class="hljs-string">“永和大王”</span></span>, <span class="hljs-number"><span class="hljs-number">580</span></span>, <span class="hljs-number"><span class="hljs-number">3000</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);<br>    Property p4 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Property(<span class="hljs-string"><span class="hljs-string">“肯德基”</span></span>, <span class="hljs-number"><span class="hljs-number">6000</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>);<br><pre><code>List&amp;lt;Property&amp;gt; properties = Arrays.asList(p1, p2, p3, p4);<br><br>Collections.sort(properties, (x, y) -&amp;gt; x.distance.compareTo(y.distance));<br><br>String name = properties.get(&lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-number”</span>&gt;<span class="hljs-number">0</span>&lt;/span&gt;).name;<br>System.out.println(&lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-string”</span>&gt;<span class="hljs-string">“距离我最近的店铺是:”</span>&lt;/span&gt; + name);<br></code></pre><br></code><p><code class="language-java hljs">}<br></code></p></pre><p></p><br><p>这里也使用了部分<code>lambda</code>表达式，在Java8之前你可能写的更痛苦一些。<br>要是要处理大量元素又该怎么办呢？为了提高性能，你需要并行处理，并利用多核架构。<br>但写并行代码比用迭代器还要复杂，而且调试起来也够受的！</p><br><p>但<code>Stream</code>中操作这些东西当然是非常简单的，小试牛刀:</p><br><pre><code class="language-java hljs"><span class="hljs-comment"><span class="hljs-comment">// Stream操作</span></span><br>String name2 = properties.stream()<br>                .sorted(Comparator.comparingInt(x -&gt; x.distance))<br>                .findFirst()<br>                .get().name;<br>System.out.println(<span class="hljs-string"><span class="hljs-string">“距离我最近的店铺是:”</span></span> + name);<br></code></pre><br><p>新的API对所有的集合操作都提供了生成流操作的方法，写的代码也行云流水，我们非常简单的就筛选了离我最近的店铺。<br>在后面我们继续讲解<code>Stream</code>更多的特性和玩法。</p><br><h2>外部迭代和内部迭代</h2><br><p>当你处理集合时，通常会对它进行迭代，然后处理返回的每个元素。比如我想看看月销量大于1000的店铺个数。</p><br><h3>使用for循环进行迭代</h3><br><pre><code class="language-java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>;<br><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Property property : properties) {<br>    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(property.sales &gt; <span class="hljs-number"><span class="hljs-number">1000</span></span>){<br>        count++;<br>    }<br>}<br></code></pre><br><p>上面的操作是可行的，但是当每次迭代的时候你需要些很多重复的代码。将<code>for</code>循环修改为并行执行也非常困难，<br>需要修改每个<code>for</code>的实现。</p><br><p>从集合背后的原理来看，<code>for</code>循环封装了迭代的语法糖，首先调用<code>iterator</code>方法，产生一个<code>Iterator</code>对象，<br>然后控制整个迭代，这就是<strong>外部迭代</strong>。迭代的过程通过调用<code>Iterator</code>对象的<code>hasNext</code>和<code>next</code>方法完成。</p><br><h3>使用迭代器进行计算</h3><br><pre><code class="language-java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>;<br>Iterator&lt;Property&gt; iterator = properties.iterator();<br><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(iterator.hasNext()){<br>    Property property = iterator.next();<br>    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(property.sales &gt; <span class="hljs-number"><span class="hljs-number">1000</span></span>){<br>        count++;<br>    }<br>}<br></code></pre><br><p>而迭代器也是有问题的。它很难抽象出<strong>未知的不能操作</strong>；此外它本质上还是串行化的操作，总体来看使用<br><code>for</code>循环会将行为和方法混为一谈。</p><br><p>另一种办法是使用内部迭代完成，<code>properties.stream()</code>该方法返回一个<code>Stream</code>而不是迭代器。</p><br><h3>使用内部迭代进行计算</h3><br><pre><code class="language-java hljs"><span class="hljs-keyword"><span class="hljs-keyword">long</span></span> count2 = properties.stream()<br>                .filter(p -&gt; p.sales &gt; <span class="hljs-number"><span class="hljs-number">1000</span></span>)<br>                .count();<br></code></pre><br><p>上述代码是通过<code>Stream API</code>完成的，我们可以把它理解为2个步骤：</p><br><ol><br><li>找出所有销量大于1000的店铺</li><br><li>计算出店铺个数</li><br></ol><br><p>为了找出销量大于1000的店铺，需要先做一次过滤：<code>filter</code>，你可以看看这个方法的入参就是前面讲到的<code>Predicate</code>断言型函数式接口，<br>测试一个函数完成后，返回值为<code>boolean</code>。<br>由于<code>Stream API</code>的风格，我们没有改变集合的内容，而是描述了<code>Stream</code>的内容，最终调用<code>count()</code>方法计算出<code>Stream</code><br>里包含了多少个过滤之后的对象，返回值为<code>long</code>。</p><br><h2>创建Stream</h2><br><p>你已经知道Java8种在<code>Collection</code>接口添加了<code>Stream</code>方法，可以将任何集合转换成一个<code>Stream</code>。<br>如果你操作的是一个数组可以使用<code>Stream.of(1, 2, 3)</code>方法将它转换为一个流。</p><br><p>也许有人知道JDK7中添加了一些类库如<code>Files.readAllLines(Paths.get(“/home/biezhi/a.txt”))</code>这样的读取文件行方法。<br><code>List</code>作为<code>Collection</code>的子类拥有转换流的方法，那么我们读取这个文本文件到一个字符串变量中将变得更简洁：</p><br><pre><code class="language-java hljs">String content = Files.readAllLines(Paths.get(<span class="hljs-string"><span class="hljs-string">“/home/biezhi/a.txt”</span></span>)).stream()<br>            .collect(Collectors.joining(<span class="hljs-string"><span class="hljs-string">“\n”</span></span>));<br></code></pre><br><p>这里的<code>collect</code>是后面要讲解的<strong>收集器</strong>，对<code>Stream</code>进行了处理后得到一个文本文件的内容。</p><br><p>JDK8也为我们提供了一些便捷的<code>Stream</code>相关类库:</p><br><p>{% image /static/img/article/java8-stream-class.png 320 500 java8提供的Stream类库 %}</p><br><p>创建一个流是很简单的，下面我们试试用创建好的<code>Stream</code>做一些操作吧。</p><br><h2>流操作</h2><br><p><code>java.util.stream.Stream</code>中定义了许多流操作的方法，为了更好的理解<code>Stream API</code>掌握它常用的操作非常重要。<br>流的操作其实可以分为两类：<strong>处理操作</strong>、<strong>聚合操作</strong>。</p><br><ul><br><li>处理操作：诸如<code>filter</code>、<code>map</code>等处理操作将<code>Stream</code>一层一层的进行抽离，返回一个流给下一层使用。</li><br><li>聚合操作：从最后一次流中生成一个结果给调用方，<code>foreach</code>只做处理不做返回。</li><br></ul><br><h3>filter</h3><br><p><code>filter</code>看名字也知道是过滤的意思，我们通常在筛选数据的时候用到，频率非常高。<br><code>filter</code>方法的参数是<code>Predicate&lt;T&gt; predicate</code>即一个从<code>T</code>到boolean的函数。</p><br><p>{% image /static/img/article/java8-filter.png 300 200 %}</p><br><p><strong>筛选出距离我在1000米内的店铺</strong></p><br><pre><code class="language-java hljs">properties.stream()<br>            .filter(p -&gt; p.distance &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>)<br></code></pre><br><p><strong>筛选出名称大于5个字的店铺</strong></p><br><pre><code class="language-java hljs">properties.stream()<br>            .filter(p -&gt; p.name.length() &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>);<br></code></pre><br><h3>map</h3><br><p>有时候我们需要将流中处理的数据类型进行转换，这时候就可以使用<code>map</code>方法来完成，将流中的值转换为一个新的流。</p><br><p>{% image /static/img/article/java8-map.png 300 200 %}</p><br><p><strong>列出所有店铺的名称</strong></p><br><pre><code class="language-java hljs">properties.stream()<br>            .map(p -&gt; p.name);<br></code></pre><br><p>传给<code>map</code>的<code>lambda</code>表达式接收一个<code>Property</code>类型的参数，返回一个<code>String</code>。<br>参数和返回值不必属于同一种类型，但是<code>lambda</code>表达式必须是<code>Function</code>接口的一个实例。</p><br><h3>flatMap</h3><br><p>有时候我们会遇到提取子流的操作，这种情况用的不多但是遇到<code>flatMap</code>将变得更容易处理。</p><br><p>{% image /static/img/article/java8-flatmap.png 300 200 %}</p><br><p>例如我们有一个<code>List&lt;List&lt;String&gt;&gt;</code>结构的数据：</p><br><pre><code class="language-java hljs">List&lt;List&lt;String&gt;&gt; lists = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();<br>        lists.add(Arrays.asList(<span class="hljs-string"><span class="hljs-string">“apple”</span></span>, <span class="hljs-string"><span class="hljs-string">“click”</span></span>));<br>        lists.add(Arrays.asList(<span class="hljs-string"><span class="hljs-string">“boss”</span></span>, <span class="hljs-string"><span class="hljs-string">“dig”</span></span>, <span class="hljs-string"><span class="hljs-string">“qq”</span></span>, <span class="hljs-string"><span class="hljs-string">“vivo”</span></span>));<br>        lists.add(Arrays.asList(<span class="hljs-string"><span class="hljs-string">“c#”</span></span>, <span class="hljs-string"><span class="hljs-string">“biezhi”</span></span>));<br></code></pre><br><p>要做的操作是获取这些数据中长度大于2的单词个数</p><br><pre><code class="language-javascript hljs">lists.stream()<br>        .flatMap(Collection::stream)<br>        .filter(str -&gt; str.length() &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>)<br>        .count();<br></code></pre><br><p>在不使用<code>flatMap</code>前你可能需要做2次<code>for</code>循环。这里调用了<code>List</code>的<code>stream</code>方法将每个列表转换成<code>Stream</code>对象，<br>其他的就和之前的操作一样。</p><br><h2>max和min</h2><br><p><code>Stream</code>中常用的操作之一是求最大值和最小值，<code>Stream API</code> 中的<code>max</code>和<code>min</code>操作足以解决这一问题。</p><br><p>我们需要筛选出价格最低的店铺:</p><br><pre><code class="language-java hljs">Property property = properties.stream()<br>            .max(Comparator.comparingInt(p -&gt; p.priceLevel))<br>            .get();<br></code></pre><br><p>查找<code>Stream</code>中的最大或最小元素，首先要考虑的是用什么作为排序的指标。<br>以查找价格最低的店铺为例，排序的指标就是<strong>店铺的价格等级</strong>。</p><br><p>为了让<code>Stream</code>对象按照价格等级进行排序，需要传给它一个<code>Comparator</code>对象。<br>Java8提供了一个新的静态方法<code>comparingInt</code>，使用它可以方便地实现一个比较器。<br>放在以前，我们需要比较两个对象的某项属性的值，现在只需要提供一个存取方法就够了。</p><br><h2>收集结果</h2><br><p>通常我们处理完流之后想查看一下结果，比如获取总数，转换结果，在前面的示例中你发现调用了<br><code>filter</code>、<code>map</code>之后没有下文了，后续的操作应该调用<code>Stream</code>中的<code>collect</code>方法完成。</p><br><p><strong>获取距离我最近的2个店铺</strong></p><br><pre><code class="language-java hljs">List&lt;Property&gt; properties = properties.stream()<br>            .sorted(Comparator.comparingInt(x -&gt; x.distance))<br>            .limit(<span class="hljs-number"><span class="hljs-number">2</span></span>)<br>            .collect(Collectors.toList());<br></code></pre><br><p><strong>获取所有店铺的名称</strong></p><br><pre><code class="language-java hljs">List&lt;String&gt; names = properties.stream()<br>                      .map(p -&gt; p.name)<br>                      .collect(Collectors.toList());<br></code></pre><br><p><strong>获取每个店铺的价格等级</strong></p><br><pre><code class="language-java hljs">Map&lt;String, Integer&gt; map = properties.stream()<br>        .collect(Collectors.toMap(Property::getName, Property::getPriceLevel));<br></code></pre><br><p><strong>所有价格等级的店铺列表</strong></p><br><pre><code class="language-java hljs">Map&lt;Integer, List&lt;Property&gt;&gt; priceMap = properties.stream()<br>                .collect(Collectors.groupingBy(Property::getPriceLevel));<br></code></pre><br><h2>并行数据处理</h2><br><h3>并行和并发</h3><br><p>并发是两个任务共享时间段，并行则是两个任务在同一时间发生，比如运行在多核CPU上。<br>如果一个程序要运行两个任务，并且只有一个CPU给它们分配了不同的时间片，那么这就是并发，而不是并行。</p><br><blockquote><br><p>并行化是指为缩短任务执行时间，将一个任务分解成几部分，然后并行执行。</p><br></blockquote><br><p>这和顺序执行的任务量是一样的，区别就像用更多的马来拉车，花费的时间自然减少了。<br>实际上，和顺序执行相比，并行化执行任务时，CPU承载的工作量更大。</p><br><blockquote><br><p>数据并行化是指将数据分成块，为每块数据分配单独的处理单元。</p><br></blockquote><br><p>还是拿马拉车那个例子打比方，就像从车里取出一些货物，放到另一辆车上，两辆马车都沿着同样的路径到达目的地。</p><br><p>当需要在大量数据上执行同样的操作时，数据并行化很管用。<br>它将问题分解为可在多块数据上求解的形式，然后对每块数据执行运算，最后将各数据块上得到的结果汇总，从而获得最终答案。</p><br><p>人们经常拿任务并行化和数据并行化做比较，在任务并行化中，线程不同，工作各异。<br>我们最常遇到的JavaEE应用容器便是任务并行化的例子之一，每个线程不光可以为不同用户服务，<br>还可以为同一个用户执行不同的任务，比如登录或往购物车添加商品。</p><br><h3>Stream并行流</h3><br><p>流使得计算变得容易，它的操作也非常简单，但你需要遵守一些约定。默认情况下我们使用集合的<code>stream</code>方法<br>创建的是一个串行流，你有两种办法让他变成并行流。</p><br><ol><br><li>调用<code>Stream</code>对象的<code>parallel</code>方法</li><br><li>创建流的时候调用<code>parallelStream</code>而不是<code>stream</code>方法</li><br></ol><br><p>我们来用具体的例子来解释串行和并行流</p><br><p><strong>串行化计算</strong></p><br><p>筛选出价格等级小于4，按照距离排序的2个店铺名</p><br><pre><code class="language-java hljs">properties.stream()<br>            .filter(p -&gt; p.priceLevel &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>)<br>            .sorted(Comparator.comparingInt(Property::getDistance))<br>            .map(Property::getName)<br>            .limit(<span class="hljs-number"><span class="hljs-number">2</span></span>)<br>            .collect(Collectors.toList());<br></code></pre><br><p>调用 parallelStream 方法即能并行处理</p><br><pre><code class="language-java hljs">properties.parallelStream()<br>            .filter(p -&gt; p.priceLevel &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>)<br>            .sorted(Comparator.comparingInt(Property::getDistance))<br>            .map(Property::getName)<br>            .limit(<span class="hljs-number"><span class="hljs-number">2</span></span>)<br>            .collect(Collectors.toList());<br></code></pre><br><p>读到这里，大家的第一反应可能是立即将手头代码中的<code>stream</code>方法替换为<code>parallelStream</code>方法，<br>因为这样做简直太简单了！先别忙，为了将硬件物尽其用，利用好并行化非常重要，但流类库提供的数据并行化只是其中的一种形式。</p><br><p>我们先要问自己一个问题：<code>并行化运行基于流的代码是否比串行化运行更快？</code>这不是一个简单的问题。<br>回到前面的例子，哪种方式花的时间更多取决于串行或并行化运行时的环境。</p><br><pre><code class="hljs apache"><span class="hljs-section">&lt;/div&gt;</span><br></code></pre><br><br><br>    ]]></content>
      
        
    </entry>
    
  
  
</search>
