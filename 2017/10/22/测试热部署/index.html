<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> 如何在java8中对HashMap排序？ · Hexo</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="如何在java8中对HashMap排序？ - chengzheng"><meta name="keywords"><meta name="author" content="chengzheng"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="http://chengzz.vip/atom.xml" title="Hexo"></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/categories/live/" target="_self" data-hover="生活" class="nav-list-link">生活</a></li><li class="nav-list-item"><a href="/categories/film/" target="_self" data-hover="摄影" class="nav-list-link">摄影</a></li><li class="nav-list-item"><a href="/about/" target="_self" data-hover="关于" class="nav-list-link">关于</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">如何在java8中对HashMap排序？</h1><div class="post-info">2017-10-22<p class="visit"><i data-hk-page="current">-</i><span>次访问</span></p></div><div class="post-content"><div id="post-content" class="post-content" itemprop="articleBody"><br>        <p class="post-tags"><a href="/tag/java8">java8</a><a href="/tag/%E6%8E%92%E5%BA%8F">排序</a><a href="/tag/HashMap">HashMap</a></p><br>        <p>随着java8的发布、使得java语言也具有了函数式编程的功能，那我们如何在日常的开发中利用好这一个特性呢？例如我们如何使用java8中的lambda表达式和Stream API对Map进行排序？那就是这篇文章要和大家探讨的问题。首先我要向大家介绍如何通过java8的lambda和Stream Api对Map进行排序。其次还要和大家分享java8中的一些核心特性。<br>顺便说一句、并不全是因为lambda表达式和Stream使得java编程变得有趣，还有一些新的API被加入到已经存在的接口当中，例如 Comparator, Map.Entry  才使得java编程变得越来越有趣。</p><br><p>通过在接口上引入非抽象方法，例如默认方法和静态方法，可以实现对现有接口的扩展。</p><br><p>使用这种方式，可以将新方法添加到现有的Java接口中，而Java API设计人员已经利用这些方法在流行的现有接口中添加了急需的多中方法。</p><br><p>其中一个最好的例子是java.util.Comparator。比较器接口现在已经有了comparing()和 thenComparing()方法通过此方法可以链多个比较器进行了比较，这使得比较多个字段比较容易。</p><br><p>java.util.Map类的内部静态类Map.Entry同样也不甘落后，它有两个额外的方法comparingByKey() 和comparingByValue()，这两个方法分别通过键和值对Map进行排序。同时这两个方法也可以和Stream中的Sorted方法一起对HashMap进行值排序。</p><br><p><u><strong>Sorting Map by values on Increasing order</strong></u><br>你可以在java8中使用java.util.stream.Stream类中的sorted()方法对Map(HashMap,LinkedHashMap或者TreeMap)排序.那意味着接受一个Comparator来作为排序器来定义排序的规则.如果你想通过值进行排序、那么你应该使用Map.Entry中的comparingByValue()方法，这个方法是java8为了提升排序的简洁性而新增加的方法.</p><br><pre><code class="language-java hljs">ItemToPrice.entrySet()<br>.stream()<br>.sorted(Map.Entry.&lt;String, Integer&gt;comparingByValue())<br>.forEach(System.out::println);<br></code></pre><br><p>但是如果你需要的是一个Map而不仅仅是将结果输出到控制台,那么你可以将结果使用Stream和Collectors类中的collect()方法来收集结果.如下所示:</p><br><pre><code class="language-java hljs"><span class="hljs-comment">// now, let’s collect the sorted entries in </span><br>Map Map&lt;String, Integer&gt; sortedByPrice = ItemToPrice.entrySet() .stream() .<br>sorted(Map.Entry.&lt;String, Integer&gt;comparingByValue()) .<br>collect(Collectors.toMap(e -&gt; e.getKey(),e -&gt; e.getValue()));<br></code></pre><br><p>上面代码不能正确的排序，因为当你在Map中收集结果结果的时候、排序的顺序已经被打乱了，所以你需要使用LinkedHashMap来保存序列；</p><br><pre><code class="language-java hljs">Map&lt;String, Integer&gt; sortedByValue = ItemToPrice.entrySet() .stream() .<br>sorted(Map.Entry.&lt;String, Integer&gt;comparingByValue()) .<br>collect(toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt;<br>e1, LinkedHashMap::<span class="hljs-keyword">new</span>))<br><br></code></pre><br><p>以上才是在java8中正确的排序方式。因为我们使用LinkedHashMap来存储entries对象.这也是一个在java8中使用构造器引用的例子.</p><br><p><u><strong>Sorting Map by values on decreasing Order</strong></u><br>为了通过降序对Map进行排序，我们只需要传递一个按照反向序列的Comparator.你可以使用java.util.Comparator中的reversed()方法.这个方法同样也是java8新加入Comparator类中的.</p><br><pre><code class="language-java hljs">Map&lt;String, Integer&gt; sortedByValueDesc = ItemToPrice.entrySet() .stream() .<br>sorted(Map.Entry.&lt;String, Integer&gt;comparingByValue().reversed()) .<br>collect(toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt;<br>e1, LinkedHashMap::<span class="hljs-keyword">new</span>));<br><br></code></pre><br><p>这里的重点是reversed()方法的使用.其他的代码和之前的代码是一样的.首先你从Map中得到一个   entry set,然后得到一个Stream,使用sorted()方法对元素进行排序,同样sort()需要comparator.</p><br><p>你提供了一个通过值进行排序的Comparator,然后调用reverse()方法倒置它，这样所有的元素就会按照倒叙进行排列.最后在你收集元素到Map过程中，你要求Collector使用LinkedHashMap来收集元素,注意这里使用了方法引用，与方法引用不同的是方法引用是通过名称来调用方法、而这里使用new关键字而已.</p><br><p><u><strong>Important points to Remember</strong></u></p><br><p>总之,在我们对Map进行排序时候，有一些观点或许是我们需要注意的,对于我们正确的排序HashMap和HashTable同样很重要.</p><br><ol><br><li>使用LinkedHashMap来保持原来排序结果的完整性</li><br><li>为了更好的可读性尽量使用静态导入例如 static import Map.Entry</li><br><li>使用内部类Map.Entry中新加入的comparingByKey()和comparingByValue() 来简化排序</li><br><li>使用reversed()方法降序排序</li><br><li>使用foreach输出Map</li><br><li>使用Collectors收集结果到Map当中,但是始终使用LinkedHashMap因为它保持了原始的排序顺序</li><br></ol><br><p>你可以继续学习java8中的其他特性，给大家推荐一本书</p><br><div class="separator" style="clear: both; text-align: center;"><br><a href="http://aax-us-east.amazon-adsystem.com/x/c/QtqdUhT6eHChVaiw5_26ON0AAAFe8kxdcwEAAAFKAQl0Vq8/http://www.amazon.com/Java-SE8-Really-Impatient-Course/dp/0321927761/ref=as_at?creativeASIN=0321927761&amp;linkCode=w61&amp;imprToken=wmvN5f2LUNVzpx3CpDy-2w&amp;slotNum=3&amp;tag=javamysqlanta-20" rel="nofollow" target="_blank" style="margin-left: 1em; margin-right: 1em;" data-amzn-asin="0321927761"><img border="0" data-original-height="649" data-original-width="501" height="320" src="https://4.bp.blogspot.com/-SHiZYPAgvNw/WW4nvFlSyhI/AAAAAAAAJEk/aO6Zgi2tRtY9ZUaEB5AJBQ4xVD8t9HwgQCLcBGAs/s320/Java%2BSE%2B8%2Bfor%2BReally%2BImpatient%2BBest%2BBook.jpg" width="247"></a></div><br><p><strong><u># # Java Program to Sort the Map by Values in JDK 8</u></strong><br>这里我列出了在java8中如何利用lambda表达式对HashMap进行值排序的完整示例,使用到了方法引用,Map.Entry的comparingByValue方法.这些方法的引入使得排序更加简单明了.</p><br><pre><code class="language-java hljs"><span class="hljs-comment">/<em> </em> To change this license header, choose License Headers in Project Properties. <em> To change this template file, choose Tools | Templates </em> and open the template in the editor. <em>/</em></span><br><span class="hljs-keyword">package</span> test;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.LinkedHashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.stream.Collectors.;<br><br><span class="hljs-comment">/<strong><br> <em> </em> <span class="hljs-doctag">@author</span> Javin Paul<br> */</strong></span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortingMapByValueInJava8</span> </span>{<br>    <span class="hljs-comment">/<br>     <em> <span class="hljs-doctag">@param</span> args </em> the command line arguments<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        Map&lt;String, Integer&gt; ItemToPrice = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        ItemToPrice.put(<span class="hljs-string">“Sony Braiva”</span>, <span class="hljs-number">1000</span>);<br>        ItemToPrice.put(<span class="hljs-string">“Apple iPhone 6S”</span>, <span class="hljs-number">1200</span>);<br>        ItemToPrice.put(<span class="hljs-string">“HP Laptop”</span>, <span class="hljs-number">700</span>);<br>        ItemToPrice.put(<span class="hljs-string">“Acer HD Monitor”</span>, <span class="hljs-number">139</span>);<br>        ItemToPrice.put(<span class="hljs-string">“Samsung Galaxy”</span>, <span class="hljs-number">800</span>);<br><br>        System.out.println(<span class="hljs-string">“unsorted Map: “</span> + ItemToPrice);<br><br>        ItemToPrice.entrySet().stream()<br>                .sorted(Map.Entry.&lt;String, Integer&gt; comparingByValue())<br>                .forEach(System.out::println);<br>        Map&lt;String, Integer&gt; sortedByPrice = ItemToPrice.entrySet().stream() .sorted(Map.Entry.&lt;String, Integer&gt; comparingByValue()) .<br>                collect(Collectors.toMap(e -&gt; e.getKey(), e -&gt; e.getValue()));<br><br>        System.out.println(<span class="hljs-string">“Map incorrectly sorted by value in ascending order: “</span> + sortedByPrice);<br><br><br>        Map&lt;String, Integer&gt; sortedByValue = ItemToPrice .entrySet() .stream() .sorted(Map.Entry.&lt;String, Integer&gt; comparingByValue()) .<br>                collect( toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e1, LinkedHashMap::<span class="hljs-keyword">new</span>));<br><br>        System.out.println(<span class="hljs-string">“Map sorted by value in increasing order: “</span> + sortedByValue);<br><br>        Map&lt;String, Integer&gt; sortedByValueDesc = ItemToPrice .entrySet() .stream() .sorted(Map.Entry.&lt;String, Integer&gt; comparingByValue().reversed()) .<br>                collect( toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e1, LinkedHashMap::<span class="hljs-keyword">new</span>));<br>        System.out.println(<span class="hljs-string">“Map sorted by value in descending order: “</span> + sortedByValueDesc);<br><br><br>        ItemToPrice.entrySet().<br>                stream().<br>                sorted(<br>                        Map.Entry.&lt;String,Integer&gt;comparingByValue()<br>                                .reversed()<br>                ) .collect(toMap(<br>                        Map.Entry::getKey,Map.Entry::getValue,(e1,d2)-&gt; e1,LinkedHashMap::<span class="hljs-keyword">new</span>));<br><br><br>    }<br>}<br>Output unsorted Map: {Samsung Galaxy=<span class="hljs-number">800</span>, HP Laptop=<span class="hljs-number">700</span>, Sony Braiva=<span class="hljs-number">1000</span>, Acer HD Monitor=<span class="hljs-number">139</span>, Apple iPhone <span class="hljs-number">6</span>S=<span class="hljs-number">1200</span>}<br>        Acer HD Monitor=<span class="hljs-number">139</span><br>        HP Laptop=<span class="hljs-number">700</span><br>        Samsung Galaxy=<span class="hljs-number">800</span><br>        Sony Braiva=<span class="hljs-number">1000</span><br>        Apple iPhone <span class="hljs-number">6</span>S=<span class="hljs-number">1200</span><br>        Map incorrectly sorted by value in ascending order: {Samsung Galaxy=<span class="hljs-number">800</span>, HP Laptop=<span class="hljs-number">700</span>, Sony Braiva=<span class="hljs-number">1000</span>,<br>        Acer HD Monitor=<span class="hljs-number">139</span>, Apple iPhone <span class="hljs-number">6</span>S=<span class="hljs-number">1200</span>} Map sorted by value in increasing order: {Acer HD Monitor=<span class="hljs-number">139</span>,<br>        HP Laptop=<span class="hljs-number">700</span>, Samsung Galaxy=<span class="hljs-number">800</span>, Sony Braiva=<span class="hljs-number">1000</span>, Apple iPhone <span class="hljs-number">6</span>S=<span class="hljs-number">1200</span>}<br>        Map sorted by value in descending order: {Apple iPhone <span class="hljs-number">6</span>S=<span class="hljs-number">1200</span>, Sony Braiva=<span class="hljs-number">1000</span>, Samsung Galaxy=<span class="hljs-number">800</span>,<br>        HP Laptop=<span class="hljs-number">700</span>, Acer HD Monitor=<span class="hljs-number">139</span>}<br><br></code></pre><br><p>从上面的代码可以看出整数map通过值进行排序.我们打印出所有已经排序好的元素对象,如上面Acer HD Monitor 是第一个打印出来的因为他是最便宜的,并且Apple iPhone是最后一个打印出来的，因为他是最贵的.</p><br><p>在第二个例子中,虽然我们像之前那样排序，但是结果并不是我们所期望的,那是因为我们在收集collect结果的时候并没有保持他们的排序顺序.我们应该使用LinkedHashMap,LinkedHashMap能保证元素按照插入顺序排列在集合中.</p><br><p>在上面第三个和第四个例子中,我们改正了我们的错误,我们使用LinkedHashMap来手机排序好的数据流,因此元素得以正确的排序.最后一个例子我们按照降序排列.第一个是Apple ,并且Acer是最后一个.</p><br><p>以下是在java8中用一行代码对HashMap通过值进行排序.</p><br><pre><code class="language-java hljs">ItemToPrice.entrySet().<br>                stream().<br>                sorted(<br>                        Map.Entry.&lt;String,Integer&gt;comparingByValue()<br>                                .reversed()<br>                ) .collect(toMap(<br>                        Map.Entry::getKey,Map.Entry::getValue,(e1,d2)-&gt; e1,LinkedHashMap::<span class="hljs-keyword">new</span>));<br></code></pre><br><p>以上便是在java8中所有有关如何通过值排序Map的内容.你可以使用这项技术排序任何Map的实现类，例如HashMap,Hashtable,ConcurrentHashMap,TreeMap等等,如果你不需要打印或者执行任何操作,你仅仅是想排序原来的Map，那么确认使用collect()方法将排序好的流导入到Map中.并且确认使用LinkedHashMap去收集元素.否则排序结果会被丢失.</p><br><p>除此之外,你也可以进一步深入阅读以下文章.</p><br><ol><br><li><br><p><a href="http://www.shareasale.com/m-pr.cfm?merchantID=53701&amp;userID=880419&amp;productID=546412549" target="_blank" rel="external">What’s New in Java 8</a></p><br></li><br><li><br><p><a href="http://aax-us-east.amazon-adsystem.com/x/c/QtqdUhT6eHChVaiw5_26ON0AAAFe8kxdcwEAAAFKAQl0Vq8/http://www.amazon.com/Java-SE8-Really-Impatient-Course/dp/0321927761/ref=as_at?creativeASIN=0321927761&amp;linkCode=w61&amp;imprToken=wmvN5f2LUNVzpx3CpDy-2w&amp;slotNum=4&amp;tag=javamysqlanta-20" target="_blank" rel="external">Java SE 8 for Really Impatient</a></p><br></li><br></ol><br><br>    </div></div></article></div><div class="right-container"><div class="widget"><div class="category"><h4>分类归档</h4></div></div><div class="widget"><div class="tagcloud"><h4>标签云</h4></div></div><div class="widget"><div class="recent"><h4>最近文章</h4><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/22/测试热部署/">如何在java8中对HashMap排序？</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/22/testpic/">跟上Java8 - Stream API快速入门</a></li></ul></div></div><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2017/10/22/testpic/" class="next">NEXT</a></div><!--PC和WAP自适应版--><div id="SOHUCS" sid="2017/10/22/测试热部署/"> </div><script>(function() {
    var appid = 'cyt6h19Ve'; 
    var conf = 'prod_0b4b95efa2ecfede2ddfb5adcef8c394'; 
    var width = window.innerWidth || document.documentElement.clientWidth; 
    if (width < 960) { 
    window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })();</script><div class="copyright"><p>© 2016 - 2017 <a target="_blank">chengzheng</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p>闽ICP备16007301号-2</p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="http://apps.bdimg.com/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="/scripts/hit-kounter-lc-0.2.0.js"></script><script src="/scripts/arAnchor.js"></script><script src="/scripts/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>