<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> 跟上Java8 - Stream API快速入门 · Hexo</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="跟上Java8 - Stream API快速入门 - chengzheng"><meta name="keywords"><meta name="author" content="chengzheng"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="http://chengzz.vip/atom.xml" title="Hexo"></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/categories/live/" target="_self" data-hover="生活" class="nav-list-link">生活</a></li><li class="nav-list-item"><a href="/categories/film/" target="_self" data-hover="摄影" class="nav-list-link">摄影</a></li><li class="nav-list-item"><a href="/about/" target="_self" data-hover="关于" class="nav-list-link">关于</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">跟上Java8 - Stream API快速入门</h1><div class="post-info">2017-10-22<p class="visit"><i data-hk-page="current">-</i><span>次访问</span></p></div><div class="post-content"><div id="post-content" class="post-content" itemprop="articleBody"><br><br><br><br><br><br></div><br><pre><code class="hljs xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“top-gap-big”</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>在前面我们简单介绍了<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>lambda<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>表达式，Java8旨在帮助程序员写出更好的代码，<br></code></pre><br><p>其对核心类库的改进也是关键的一部分，<code>Stream</code>是Java8种处理集合的抽象概念，<br>它可以指定你希望对集合的操作，但是执行操作的时间交给具体实现来决定。</p><p></p><br><a id="more"></a><br><h2>为什么需要Stream?</h2><br><p>Java语言中集合是使用最多的API，几乎每个Java程序都会用到集合操作，<br>这里的Stream和IO中的Stream不同，它提供了对集合操作的增强，极大的提高了操作集合对象的便利性。</p><br><p>集合对于大多数编程任务而言都是基本的，为了解释集合是怎么工作，我们想象一下当下最火的外卖APP，<br>当我们点菜的时候需要按照<strong>距离</strong>、<strong>价格</strong>、<strong>销量</strong>等进行排序后筛选出自己满意的菜品。<br>你可能想选择距离自己最近的一家店铺点菜，尽管用集合可以完成这件事，但集合的操作远远算不上完美。</p><br><p>假如让你编写上面示例中的代码，你可能会写出如下：</p><br><pre><code class="language-java hljs"><span class="hljs-comment"><span class="hljs-comment">// 店铺属性</span></span><br><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Property</span></span></span><span class="hljs-class"> </span></span>{<br>    String  name;<br>    <span class="hljs-comment"><span class="hljs-comment">// 距离，单位:米</span></span><br>    Integer distance;<br>    <span class="hljs-comment"><span class="hljs-comment">// 销量，月售</span></span><br>    Integer sales;<br>    <span class="hljs-comment"><span class="hljs-comment">// 价格，这里简单起见就写一个级别代表价格段</span></span><br>    Integer priceLevel;<br><pre><code>&lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-function”</span>&gt;&lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-keyword”</span>&gt;<span class="hljs-keyword">public</span>&lt;/span&gt; &lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-title”</span>&gt;Property&lt;/span&gt;&lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-params”</span>&gt;(String name, &lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-keyword”</span>&gt;<span class="hljs-keyword">int</span>&lt;/span&gt; distance, &lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-keyword”</span>&gt;<span class="hljs-keyword">int</span>&lt;/span&gt; sales, &lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-keyword”</span>&gt;<span class="hljs-keyword">int</span>&lt;/span&gt; priceLevel)&lt;/span&gt; &lt;/span&gt;{<br>    &lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-keyword”</span>&gt;<span class="hljs-keyword">this</span>&lt;/span&gt;.name = name;<br>    &lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-keyword”</span>&gt;<span class="hljs-keyword">this</span>&lt;/span&gt;.distance = distance;<br>    &lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-keyword”</span>&gt;<span class="hljs-keyword">this</span>&lt;/span&gt;.sales = sales;<br>    &lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-keyword”</span>&gt;<span class="hljs-keyword">this</span>&lt;/span&gt;.priceLevel = priceLevel;<br>}<br>&lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-comment”</span>&gt;<span class="hljs-comment">// getter setter 省略&lt;/span&gt;</span><br></code></pre><br></code><p><code class="language-java hljs">}<br></code></p></pre><p></p><br><p>我想要筛选距离我最近的店铺，你可能会写下这样的代码：</p><br><pre><code class="language-java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{<br>    Property p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Property(<span class="hljs-string"><span class="hljs-string">“叫了个鸡”</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);<br>    Property p2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Property(<span class="hljs-string"><span class="hljs-string">“张三丰饺子馆”</span></span>, <span class="hljs-number"><span class="hljs-number">2300</span></span>, <span class="hljs-number"><span class="hljs-number">1500</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);<br>    Property p3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Property(<span class="hljs-string"><span class="hljs-string">“永和大王”</span></span>, <span class="hljs-number"><span class="hljs-number">580</span></span>, <span class="hljs-number"><span class="hljs-number">3000</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);<br>    Property p4 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Property(<span class="hljs-string"><span class="hljs-string">“肯德基”</span></span>, <span class="hljs-number"><span class="hljs-number">6000</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>);<br><pre><code>List&amp;lt;Property&amp;gt; properties = Arrays.asList(p1, p2, p3, p4);<br><br>Collections.sort(properties, (x, y) -&amp;gt; x.distance.compareTo(y.distance));<br><br>String name = properties.get(&lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-number”</span>&gt;<span class="hljs-number">0</span>&lt;/span&gt;).name;<br>System.out.println(&lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“hljs-string”</span>&gt;<span class="hljs-string">“距离我最近的店铺是:”</span>&lt;/span&gt; + name);<br></code></pre><br></code><p><code class="language-java hljs">}<br></code></p></pre><p></p><br><p>这里也使用了部分<code>lambda</code>表达式，在Java8之前你可能写的更痛苦一些。<br>要是要处理大量元素又该怎么办呢？为了提高性能，你需要并行处理，并利用多核架构。<br>但写并行代码比用迭代器还要复杂，而且调试起来也够受的！</p><br><p>但<code>Stream</code>中操作这些东西当然是非常简单的，小试牛刀:</p><br><pre><code class="language-java hljs"><span class="hljs-comment"><span class="hljs-comment">// Stream操作</span></span><br>String name2 = properties.stream()<br>                .sorted(Comparator.comparingInt(x -&gt; x.distance))<br>                .findFirst()<br>                .get().name;<br>System.out.println(<span class="hljs-string"><span class="hljs-string">“距离我最近的店铺是:”</span></span> + name);<br></code></pre><br><p>新的API对所有的集合操作都提供了生成流操作的方法，写的代码也行云流水，我们非常简单的就筛选了离我最近的店铺。<br>在后面我们继续讲解<code>Stream</code>更多的特性和玩法。</p><br><h2>外部迭代和内部迭代</h2><br><p>当你处理集合时，通常会对它进行迭代，然后处理返回的每个元素。比如我想看看月销量大于1000的店铺个数。</p><br><h3>使用for循环进行迭代</h3><br><pre><code class="language-java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>;<br><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Property property : properties) {<br>    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(property.sales &gt; <span class="hljs-number"><span class="hljs-number">1000</span></span>){<br>        count++;<br>    }<br>}<br></code></pre><br><p>上面的操作是可行的，但是当每次迭代的时候你需要些很多重复的代码。将<code>for</code>循环修改为并行执行也非常困难，<br>需要修改每个<code>for</code>的实现。</p><br><p>从集合背后的原理来看，<code>for</code>循环封装了迭代的语法糖，首先调用<code>iterator</code>方法，产生一个<code>Iterator</code>对象，<br>然后控制整个迭代，这就是<strong>外部迭代</strong>。迭代的过程通过调用<code>Iterator</code>对象的<code>hasNext</code>和<code>next</code>方法完成。</p><br><h3>使用迭代器进行计算</h3><br><pre><code class="language-java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>;<br>Iterator&lt;Property&gt; iterator = properties.iterator();<br><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(iterator.hasNext()){<br>    Property property = iterator.next();<br>    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(property.sales &gt; <span class="hljs-number"><span class="hljs-number">1000</span></span>){<br>        count++;<br>    }<br>}<br></code></pre><br><p>而迭代器也是有问题的。它很难抽象出<strong>未知的不能操作</strong>；此外它本质上还是串行化的操作，总体来看使用<br><code>for</code>循环会将行为和方法混为一谈。</p><br><p>另一种办法是使用内部迭代完成，<code>properties.stream()</code>该方法返回一个<code>Stream</code>而不是迭代器。</p><br><h3>使用内部迭代进行计算</h3><br><pre><code class="language-java hljs"><span class="hljs-keyword"><span class="hljs-keyword">long</span></span> count2 = properties.stream()<br>                .filter(p -&gt; p.sales &gt; <span class="hljs-number"><span class="hljs-number">1000</span></span>)<br>                .count();<br></code></pre><br><p>上述代码是通过<code>Stream API</code>完成的，我们可以把它理解为2个步骤：</p><br><ol><br><li>找出所有销量大于1000的店铺</li><br><li>计算出店铺个数</li><br></ol><br><p>为了找出销量大于1000的店铺，需要先做一次过滤：<code>filter</code>，你可以看看这个方法的入参就是前面讲到的<code>Predicate</code>断言型函数式接口，<br>测试一个函数完成后，返回值为<code>boolean</code>。<br>由于<code>Stream API</code>的风格，我们没有改变集合的内容，而是描述了<code>Stream</code>的内容，最终调用<code>count()</code>方法计算出<code>Stream</code><br>里包含了多少个过滤之后的对象，返回值为<code>long</code>。</p><br><h2>创建Stream</h2><br><p>你已经知道Java8种在<code>Collection</code>接口添加了<code>Stream</code>方法，可以将任何集合转换成一个<code>Stream</code>。<br>如果你操作的是一个数组可以使用<code>Stream.of(1, 2, 3)</code>方法将它转换为一个流。</p><br><p>也许有人知道JDK7中添加了一些类库如<code>Files.readAllLines(Paths.get(“/home/biezhi/a.txt”))</code>这样的读取文件行方法。<br><code>List</code>作为<code>Collection</code>的子类拥有转换流的方法，那么我们读取这个文本文件到一个字符串变量中将变得更简洁：</p><br><pre><code class="language-java hljs">String content = Files.readAllLines(Paths.get(<span class="hljs-string"><span class="hljs-string">“/home/biezhi/a.txt”</span></span>)).stream()<br>            .collect(Collectors.joining(<span class="hljs-string"><span class="hljs-string">“\n”</span></span>));<br></code></pre><br><p>这里的<code>collect</code>是后面要讲解的<strong>收集器</strong>，对<code>Stream</code>进行了处理后得到一个文本文件的内容。</p><br><p>JDK8也为我们提供了一些便捷的<code>Stream</code>相关类库:</p><br><p>{% image /static/img/article/java8-stream-class.png 320 500 java8提供的Stream类库 %}</p><br><p>创建一个流是很简单的，下面我们试试用创建好的<code>Stream</code>做一些操作吧。</p><br><h2>流操作</h2><br><p><code>java.util.stream.Stream</code>中定义了许多流操作的方法，为了更好的理解<code>Stream API</code>掌握它常用的操作非常重要。<br>流的操作其实可以分为两类：<strong>处理操作</strong>、<strong>聚合操作</strong>。</p><br><ul><br><li>处理操作：诸如<code>filter</code>、<code>map</code>等处理操作将<code>Stream</code>一层一层的进行抽离，返回一个流给下一层使用。</li><br><li>聚合操作：从最后一次流中生成一个结果给调用方，<code>foreach</code>只做处理不做返回。</li><br></ul><br><h3>filter</h3><br><p><code>filter</code>看名字也知道是过滤的意思，我们通常在筛选数据的时候用到，频率非常高。<br><code>filter</code>方法的参数是<code>Predicate&lt;T&gt; predicate</code>即一个从<code>T</code>到boolean的函数。</p><br><p>{% image /static/img/article/java8-filter.png 300 200 %}</p><br><p><strong>筛选出距离我在1000米内的店铺</strong></p><br><pre><code class="language-java hljs">properties.stream()<br>            .filter(p -&gt; p.distance &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>)<br></code></pre><br><p><strong>筛选出名称大于5个字的店铺</strong></p><br><pre><code class="language-java hljs">properties.stream()<br>            .filter(p -&gt; p.name.length() &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>);<br></code></pre><br><h3>map</h3><br><p>有时候我们需要将流中处理的数据类型进行转换，这时候就可以使用<code>map</code>方法来完成，将流中的值转换为一个新的流。</p><br><p>{% image /static/img/article/java8-map.png 300 200 %}</p><br><p><strong>列出所有店铺的名称</strong></p><br><pre><code class="language-java hljs">properties.stream()<br>            .map(p -&gt; p.name);<br></code></pre><br><p>传给<code>map</code>的<code>lambda</code>表达式接收一个<code>Property</code>类型的参数，返回一个<code>String</code>。<br>参数和返回值不必属于同一种类型，但是<code>lambda</code>表达式必须是<code>Function</code>接口的一个实例。</p><br><h3>flatMap</h3><br><p>有时候我们会遇到提取子流的操作，这种情况用的不多但是遇到<code>flatMap</code>将变得更容易处理。</p><br><p>{% image /static/img/article/java8-flatmap.png 300 200 %}</p><br><p>例如我们有一个<code>List&lt;List&lt;String&gt;&gt;</code>结构的数据：</p><br><pre><code class="language-java hljs">List&lt;List&lt;String&gt;&gt; lists = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();<br>        lists.add(Arrays.asList(<span class="hljs-string"><span class="hljs-string">“apple”</span></span>, <span class="hljs-string"><span class="hljs-string">“click”</span></span>));<br>        lists.add(Arrays.asList(<span class="hljs-string"><span class="hljs-string">“boss”</span></span>, <span class="hljs-string"><span class="hljs-string">“dig”</span></span>, <span class="hljs-string"><span class="hljs-string">“qq”</span></span>, <span class="hljs-string"><span class="hljs-string">“vivo”</span></span>));<br>        lists.add(Arrays.asList(<span class="hljs-string"><span class="hljs-string">“c#”</span></span>, <span class="hljs-string"><span class="hljs-string">“biezhi”</span></span>));<br></code></pre><br><p>要做的操作是获取这些数据中长度大于2的单词个数</p><br><pre><code class="language-javascript hljs">lists.stream()<br>        .flatMap(Collection::stream)<br>        .filter(str -&gt; str.length() &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>)<br>        .count();<br></code></pre><br><p>在不使用<code>flatMap</code>前你可能需要做2次<code>for</code>循环。这里调用了<code>List</code>的<code>stream</code>方法将每个列表转换成<code>Stream</code>对象，<br>其他的就和之前的操作一样。</p><br><h2>max和min</h2><br><p><code>Stream</code>中常用的操作之一是求最大值和最小值，<code>Stream API</code> 中的<code>max</code>和<code>min</code>操作足以解决这一问题。</p><br><p>我们需要筛选出价格最低的店铺:</p><br><pre><code class="language-java hljs">Property property = properties.stream()<br>            .max(Comparator.comparingInt(p -&gt; p.priceLevel))<br>            .get();<br></code></pre><br><p>查找<code>Stream</code>中的最大或最小元素，首先要考虑的是用什么作为排序的指标。<br>以查找价格最低的店铺为例，排序的指标就是<strong>店铺的价格等级</strong>。</p><br><p>为了让<code>Stream</code>对象按照价格等级进行排序，需要传给它一个<code>Comparator</code>对象。<br>Java8提供了一个新的静态方法<code>comparingInt</code>，使用它可以方便地实现一个比较器。<br>放在以前，我们需要比较两个对象的某项属性的值，现在只需要提供一个存取方法就够了。</p><br><h2>收集结果</h2><br><p>通常我们处理完流之后想查看一下结果，比如获取总数，转换结果，在前面的示例中你发现调用了<br><code>filter</code>、<code>map</code>之后没有下文了，后续的操作应该调用<code>Stream</code>中的<code>collect</code>方法完成。</p><br><p><strong>获取距离我最近的2个店铺</strong></p><br><pre><code class="language-java hljs">List&lt;Property&gt; properties = properties.stream()<br>            .sorted(Comparator.comparingInt(x -&gt; x.distance))<br>            .limit(<span class="hljs-number"><span class="hljs-number">2</span></span>)<br>            .collect(Collectors.toList());<br></code></pre><br><p><strong>获取所有店铺的名称</strong></p><br><pre><code class="language-java hljs">List&lt;String&gt; names = properties.stream()<br>                      .map(p -&gt; p.name)<br>                      .collect(Collectors.toList());<br></code></pre><br><p><strong>获取每个店铺的价格等级</strong></p><br><pre><code class="language-java hljs">Map&lt;String, Integer&gt; map = properties.stream()<br>        .collect(Collectors.toMap(Property::getName, Property::getPriceLevel));<br></code></pre><br><p><strong>所有价格等级的店铺列表</strong></p><br><pre><code class="language-java hljs">Map&lt;Integer, List&lt;Property&gt;&gt; priceMap = properties.stream()<br>                .collect(Collectors.groupingBy(Property::getPriceLevel));<br></code></pre><br><h2>并行数据处理</h2><br><h3>并行和并发</h3><br><p>并发是两个任务共享时间段，并行则是两个任务在同一时间发生，比如运行在多核CPU上。<br>如果一个程序要运行两个任务，并且只有一个CPU给它们分配了不同的时间片，那么这就是并发，而不是并行。</p><br><blockquote><br><p>并行化是指为缩短任务执行时间，将一个任务分解成几部分，然后并行执行。</p><br></blockquote><br><p>这和顺序执行的任务量是一样的，区别就像用更多的马来拉车，花费的时间自然减少了。<br>实际上，和顺序执行相比，并行化执行任务时，CPU承载的工作量更大。</p><br><blockquote><br><p>数据并行化是指将数据分成块，为每块数据分配单独的处理单元。</p><br></blockquote><br><p>还是拿马拉车那个例子打比方，就像从车里取出一些货物，放到另一辆车上，两辆马车都沿着同样的路径到达目的地。</p><br><p>当需要在大量数据上执行同样的操作时，数据并行化很管用。<br>它将问题分解为可在多块数据上求解的形式，然后对每块数据执行运算，最后将各数据块上得到的结果汇总，从而获得最终答案。</p><br><p>人们经常拿任务并行化和数据并行化做比较，在任务并行化中，线程不同，工作各异。<br>我们最常遇到的JavaEE应用容器便是任务并行化的例子之一，每个线程不光可以为不同用户服务，<br>还可以为同一个用户执行不同的任务，比如登录或往购物车添加商品。</p><br><h3>Stream并行流</h3><br><p>流使得计算变得容易，它的操作也非常简单，但你需要遵守一些约定。默认情况下我们使用集合的<code>stream</code>方法<br>创建的是一个串行流，你有两种办法让他变成并行流。</p><br><ol><br><li>调用<code>Stream</code>对象的<code>parallel</code>方法</li><br><li>创建流的时候调用<code>parallelStream</code>而不是<code>stream</code>方法</li><br></ol><br><p>我们来用具体的例子来解释串行和并行流</p><br><p><strong>串行化计算</strong></p><br><p>筛选出价格等级小于4，按照距离排序的2个店铺名</p><br><pre><code class="language-java hljs">properties.stream()<br>            .filter(p -&gt; p.priceLevel &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>)<br>            .sorted(Comparator.comparingInt(Property::getDistance))<br>            .map(Property::getName)<br>            .limit(<span class="hljs-number"><span class="hljs-number">2</span></span>)<br>            .collect(Collectors.toList());<br></code></pre><br><p>调用 parallelStream 方法即能并行处理</p><br><pre><code class="language-java hljs">properties.parallelStream()<br>            .filter(p -&gt; p.priceLevel &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>)<br>            .sorted(Comparator.comparingInt(Property::getDistance))<br>            .map(Property::getName)<br>            .limit(<span class="hljs-number"><span class="hljs-number">2</span></span>)<br>            .collect(Collectors.toList());<br></code></pre><br><p>读到这里，大家的第一反应可能是立即将手头代码中的<code>stream</code>方法替换为<code>parallelStream</code>方法，<br>因为这样做简直太简单了！先别忙，为了将硬件物尽其用，利用好并行化非常重要，但流类库提供的数据并行化只是其中的一种形式。</p><br><p>我们先要问自己一个问题：<code>并行化运行基于流的代码是否比串行化运行更快？</code>这不是一个简单的问题。<br>回到前面的例子，哪种方式花的时间更多取决于串行或并行化运行时的环境。</p><br><pre><code class="hljs apache"><span class="hljs-section">&lt;/div&gt;</span><br></code></pre><br><br><br>    </div></article></div><div class="right-container"><div class="widget"><div class="category"><h4>分类归档</h4></div></div><div class="widget"><div class="tagcloud"><h4>标签云</h4></div></div><div class="widget"><div class="recent"><h4>最近文章</h4><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/22/测试热部署/">如何在java8中对HashMap排序？</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/22/testpic/">跟上Java8 - Stream API快速入门</a></li></ul></div></div><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2017/10/22/测试热部署/" class="prev">上一篇</a></div><!--PC和WAP自适应版--><div id="SOHUCS" sid="2017/10/22/testpic/"> </div><script>(function() {
    var appid = 'cyt6h19Ve'; 
    var conf = 'prod_0b4b95efa2ecfede2ddfb5adcef8c394'; 
    var width = window.innerWidth || document.documentElement.clientWidth; 
    if (width < 960) { 
    window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })();</script><div class="copyright"><p>© 2016 - 2017 <a target="_blank">chengzheng</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p>闽ICP备16007301号-2</p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="http://apps.bdimg.com/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="/scripts/hit-kounter-lc-0.2.0.js"></script><script src="/scripts/arAnchor.js"></script><script src="/scripts/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>