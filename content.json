{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"chengzheng","url":"http://chengzz.vip"},"pages":[],"posts":[{"title":"如何在java8中对HashMap排序？","slug":"测试热部署","date":"2017-10-22T06:20:52.000Z","updated":"2017-10-22T07:14:03.000Z","comments":true,"path":"2017/10/22/测试热部署/","link":"","permalink":"http://chengzz.vip/2017/10/22/测试热部署/","excerpt":"","text":"java8排序HashMap 随着java8的发布、使得java语言也具有了函数式编程的功能，那我们如何在日常的开发中利用好这一个特性呢？例如我们如何使用java8中的lambda表达式和Stream API对Map进行排序？那就是这篇文章要和大家探讨的问题。首先我要向大家介绍如何通过java8的lambda和Stream Api对Map进行排序。其次还要和大家分享java8中的一些核心特性。顺便说一句、并不全是因为lambda表达式和Stream使得java编程变得有趣，还有一些新的API被加入到已经存在的接口当中，例如 Comparator, Map.Entry 才使得java编程变得越来越有趣。通过在接口上引入非抽象方法，例如默认方法和静态方法，可以实现对现有接口的扩展。使用这种方式，可以将新方法添加到现有的Java接口中，而Java API设计人员已经利用这些方法在流行的现有接口中添加了急需的多中方法。其中一个最好的例子是java.util.Comparator。比较器接口现在已经有了comparing()和 thenComparing()方法通过此方法可以链多个比较器进行了比较，这使得比较多个字段比较容易。java.util.Map类的内部静态类Map.Entry同样也不甘落后，它有两个额外的方法comparingByKey() 和comparingByValue()，这两个方法分别通过键和值对Map进行排序。同时这两个方法也可以和Stream中的Sorted方法一起对HashMap进行值排序。Sorting Map by values on Increasing order你可以在java8中使用java.util.stream.Stream类中的sorted()方法对Map(HashMap,LinkedHashMap或者TreeMap)排序.那意味着接受一个Comparator来作为排序器来定义排序的规则.如果你想通过值进行排序、那么你应该使用Map.Entry中的comparingByValue()方法，这个方法是java8为了提升排序的简洁性而新增加的方法.ItemToPrice.entrySet().stream().sorted(Map.Entry.&lt;String, Integer&gt;comparingByValue()).forEach(System.out::println);但是如果你需要的是一个Map而不仅仅是将结果输出到控制台,那么你可以将结果使用Stream和Collectors类中的collect()方法来收集结果.如下所示:// now, let’s collect the sorted entries in Map Map&lt;String, Integer&gt; sortedByPrice = ItemToPrice.entrySet() .stream() .sorted(Map.Entry.&lt;String, Integer&gt;comparingByValue()) .collect(Collectors.toMap(e -&gt; e.getKey(),e -&gt; e.getValue()));上面代码不能正确的排序，因为当你在Map中收集结果结果的时候、排序的顺序已经被打乱了，所以你需要使用LinkedHashMap来保存序列；Map&lt;String, Integer&gt; sortedByValue = ItemToPrice.entrySet() .stream() .sorted(Map.Entry.&lt;String, Integer&gt;comparingByValue()) .collect(toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt;e1, LinkedHashMap::new))以上才是在java8中正确的排序方式。因为我们使用LinkedHashMap来存储entries对象.这也是一个在java8中使用构造器引用的例子.Sorting Map by values on decreasing Order为了通过降序对Map进行排序，我们只需要传递一个按照反向序列的Comparator.你可以使用java.util.Comparator中的reversed()方法.这个方法同样也是java8新加入Comparator类中的.Map&lt;String, Integer&gt; sortedByValueDesc = ItemToPrice.entrySet() .stream() .sorted(Map.Entry.&lt;String, Integer&gt;comparingByValue().reversed()) .collect(toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt;e1, LinkedHashMap::new));这里的重点是reversed()方法的使用.其他的代码和之前的代码是一样的.首先你从Map中得到一个 entry set,然后得到一个Stream,使用sorted()方法对元素进行排序,同样sort()需要comparator.你提供了一个通过值进行排序的Comparator,然后调用reverse()方法倒置它，这样所有的元素就会按照倒叙进行排列.最后在你收集元素到Map过程中，你要求Collector使用LinkedHashMap来收集元素,注意这里使用了方法引用，与方法引用不同的是方法引用是通过名称来调用方法、而这里使用new关键字而已.Important points to Remember总之,在我们对Map进行排序时候，有一些观点或许是我们需要注意的,对于我们正确的排序HashMap和HashTable同样很重要.使用LinkedHashMap来保持原来排序结果的完整性为了更好的可读性尽量使用静态导入例如 static import Map.Entry使用内部类Map.Entry中新加入的comparingByKey()和comparingByValue() 来简化排序使用reversed()方法降序排序使用foreach输出Map使用Collectors收集结果到Map当中,但是始终使用LinkedHashMap因为它保持了原始的排序顺序你可以继续学习java8中的其他特性，给大家推荐一本书# # Java Program to Sort the Map by Values in JDK 8这里我列出了在java8中如何利用lambda表达式对HashMap进行值排序的完整示例,使用到了方法引用,Map.Entry的comparingByValue方法.这些方法的引入使得排序更加简单明了./ To change this license header, choose License Headers in Project Properties. To change this template file, choose Tools | Templates and open the template in the editor. /package test;import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;import java.util.stream.Collectors;import static java.util.stream.Collectors.;/ @author Javin Paul */public class SortingMapByValueInJava8 { / @param args the command line arguments */ public static void main(String[] args) { Map&lt;String, Integer&gt; ItemToPrice = new HashMap&lt;&gt;(); ItemToPrice.put(“Sony Braiva”, 1000); ItemToPrice.put(“Apple iPhone 6S”, 1200); ItemToPrice.put(“HP Laptop”, 700); ItemToPrice.put(“Acer HD Monitor”, 139); ItemToPrice.put(“Samsung Galaxy”, 800); System.out.println(“unsorted Map: “ + ItemToPrice); ItemToPrice.entrySet().stream() .sorted(Map.Entry.&lt;String, Integer&gt; comparingByValue()) .forEach(System.out::println); Map&lt;String, Integer&gt; sortedByPrice = ItemToPrice.entrySet().stream() .sorted(Map.Entry.&lt;String, Integer&gt; comparingByValue()) . collect(Collectors.toMap(e -&gt; e.getKey(), e -&gt; e.getValue())); System.out.println(“Map incorrectly sorted by value in ascending order: “ + sortedByPrice); Map&lt;String, Integer&gt; sortedByValue = ItemToPrice .entrySet() .stream() .sorted(Map.Entry.&lt;String, Integer&gt; comparingByValue()) . collect( toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e1, LinkedHashMap::new)); System.out.println(“Map sorted by value in increasing order: “ + sortedByValue); Map&lt;String, Integer&gt; sortedByValueDesc = ItemToPrice .entrySet() .stream() .sorted(Map.Entry.&lt;String, Integer&gt; comparingByValue().reversed()) . collect( toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e1, LinkedHashMap::new)); System.out.println(“Map sorted by value in descending order: “ + sortedByValueDesc); ItemToPrice.entrySet(). stream(). sorted( Map.Entry.&lt;String,Integer&gt;comparingByValue() .reversed() ) .collect(toMap( Map.Entry::getKey,Map.Entry::getValue,(e1,d2)-&gt; e1,LinkedHashMap::new)); }}Output unsorted Map: {Samsung Galaxy=800, HP Laptop=700, Sony Braiva=1000, Acer HD Monitor=139, Apple iPhone 6S=1200} Acer HD Monitor=139 HP Laptop=700 Samsung Galaxy=800 Sony Braiva=1000 Apple iPhone 6S=1200 Map incorrectly sorted by value in ascending order: {Samsung Galaxy=800, HP Laptop=700, Sony Braiva=1000, Acer HD Monitor=139, Apple iPhone 6S=1200} Map sorted by value in increasing order: {Acer HD Monitor=139, HP Laptop=700, Samsung Galaxy=800, Sony Braiva=1000, Apple iPhone 6S=1200} Map sorted by value in descending order: {Apple iPhone 6S=1200, Sony Braiva=1000, Samsung Galaxy=800, HP Laptop=700, Acer HD Monitor=139}从上面的代码可以看出整数map通过值进行排序.我们打印出所有已经排序好的元素对象,如上面Acer HD Monitor 是第一个打印出来的因为他是最便宜的,并且Apple iPhone是最后一个打印出来的，因为他是最贵的.在第二个例子中,虽然我们像之前那样排序，但是结果并不是我们所期望的,那是因为我们在收集collect结果的时候并没有保持他们的排序顺序.我们应该使用LinkedHashMap,LinkedHashMap能保证元素按照插入顺序排列在集合中.在上面第三个和第四个例子中,我们改正了我们的错误,我们使用LinkedHashMap来手机排序好的数据流,因此元素得以正确的排序.最后一个例子我们按照降序排列.第一个是Apple ,并且Acer是最后一个.以下是在java8中用一行代码对HashMap通过值进行排序.ItemToPrice.entrySet(). stream(). sorted( Map.Entry.&lt;String,Integer&gt;comparingByValue() .reversed() ) .collect(toMap( Map.Entry::getKey,Map.Entry::getValue,(e1,d2)-&gt; e1,LinkedHashMap::new));以上便是在java8中所有有关如何通过值排序Map的内容.你可以使用这项技术排序任何Map的实现类，例如HashMap,Hashtable,ConcurrentHashMap,TreeMap等等,如果你不需要打印或者执行任何操作,你仅仅是想排序原来的Map，那么确认使用collect()方法将排序好的流导入到Map中.并且确认使用LinkedHashMap去收集元素.否则排序结果会被丢失.除此之外,你也可以进一步深入阅读以下文章.What’s New in Java 8Java SE 8 for Really Impatient","categories":[],"tags":[]},{"title":"跟上Java8 - Stream API快速入门","slug":"testpic","date":"2017-10-22T05:47:24.000Z","updated":"2017-10-22T07:16:59.000Z","comments":true,"path":"2017/10/22/testpic/","link":"","permalink":"http://chengzz.vip/2017/10/22/testpic/","excerpt":"&lt;/div&gt;&lt;div class=“top-gap-big”&gt; &lt;p&gt;在前面我们简单介绍了&lt;code&gt;lambda&lt;/code&gt;表达式，Java8旨在帮助程序员写出更好的代码，其对核心类库的改进也是关键的一部分，Stream是Java8种处理集合的抽象概念，它可以指定你希望对集合的操作，但是执行操作的时间交给具体实现来决定。","text":"&lt;/div&gt;&lt;div class=“top-gap-big”&gt; &lt;p&gt;在前面我们简单介绍了&lt;code&gt;lambda&lt;/code&gt;表达式，Java8旨在帮助程序员写出更好的代码，其对核心类库的改进也是关键的一部分，Stream是Java8种处理集合的抽象概念，它可以指定你希望对集合的操作，但是执行操作的时间交给具体实现来决定。为什么需要Stream?Java语言中集合是使用最多的API，几乎每个Java程序都会用到集合操作，这里的Stream和IO中的Stream不同，它提供了对集合操作的增强，极大的提高了操作集合对象的便利性。集合对于大多数编程任务而言都是基本的，为了解释集合是怎么工作，我们想象一下当下最火的外卖APP，当我们点菜的时候需要按照距离、价格、销量等进行排序后筛选出自己满意的菜品。你可能想选择距离自己最近的一家店铺点菜，尽管用集合可以完成这件事，但集合的操作远远算不上完美。假如让你编写上面示例中的代码，你可能会写出如下：// 店铺属性public class Property { String name; // 距离，单位:米 Integer distance; // 销量，月售 Integer sales; // 价格，这里简单起见就写一个级别代表价格段 Integer priceLevel;&lt;span class=“hljs-function”&gt;&lt;span class=“hljs-keyword”&gt;public&lt;/span&gt; &lt;span class=“hljs-title”&gt;Property&lt;/span&gt;&lt;span class=“hljs-params”&gt;(String name, &lt;span class=“hljs-keyword”&gt;int&lt;/span&gt; distance, &lt;span class=“hljs-keyword”&gt;int&lt;/span&gt; sales, &lt;span class=“hljs-keyword”&gt;int&lt;/span&gt; priceLevel)&lt;/span&gt; &lt;/span&gt;{ &lt;span class=“hljs-keyword”&gt;this&lt;/span&gt;.name = name; &lt;span class=“hljs-keyword”&gt;this&lt;/span&gt;.distance = distance; &lt;span class=“hljs-keyword”&gt;this&lt;/span&gt;.sales = sales; &lt;span class=“hljs-keyword”&gt;this&lt;/span&gt;.priceLevel = priceLevel;}&lt;span class=“hljs-comment”&gt;// getter setter 省略&lt;/span&gt;}我想要筛选距离我最近的店铺，你可能会写下这样的代码：public static void main(String[] args) { Property p1 = new Property(“叫了个鸡”, 1000, 500, 2); Property p2 = new Property(“张三丰饺子馆”, 2300, 1500, 3); Property p3 = new Property(“永和大王”, 580, 3000, 1); Property p4 = new Property(“肯德基”, 6000, 200, 4);List&amp;lt;Property&amp;gt; properties = Arrays.asList(p1, p2, p3, p4);Collections.sort(properties, (x, y) -&amp;gt; x.distance.compareTo(y.distance));String name = properties.get(&lt;span class=“hljs-number”&gt;0&lt;/span&gt;).name;System.out.println(&lt;span class=“hljs-string”&gt;“距离我最近的店铺是:”&lt;/span&gt; + name);}这里也使用了部分lambda表达式，在Java8之前你可能写的更痛苦一些。要是要处理大量元素又该怎么办呢？为了提高性能，你需要并行处理，并利用多核架构。但写并行代码比用迭代器还要复杂，而且调试起来也够受的！但Stream中操作这些东西当然是非常简单的，小试牛刀:// Stream操作String name2 = properties.stream() .sorted(Comparator.comparingInt(x -&gt; x.distance)) .findFirst() .get().name;System.out.println(“距离我最近的店铺是:” + name);新的API对所有的集合操作都提供了生成流操作的方法，写的代码也行云流水，我们非常简单的就筛选了离我最近的店铺。在后面我们继续讲解Stream更多的特性和玩法。外部迭代和内部迭代当你处理集合时，通常会对它进行迭代，然后处理返回的每个元素。比如我想看看月销量大于1000的店铺个数。使用for循环进行迭代int count = 0;for (Property property : properties) { if(property.sales &gt; 1000){ count++; }}上面的操作是可行的，但是当每次迭代的时候你需要些很多重复的代码。将for循环修改为并行执行也非常困难，需要修改每个for的实现。从集合背后的原理来看，for循环封装了迭代的语法糖，首先调用iterator方法，产生一个Iterator对象，然后控制整个迭代，这就是外部迭代。迭代的过程通过调用Iterator对象的hasNext和next方法完成。使用迭代器进行计算int count = 0;Iterator&lt;Property&gt; iterator = properties.iterator();while(iterator.hasNext()){ Property property = iterator.next(); if(property.sales &gt; 1000){ count++; }}而迭代器也是有问题的。它很难抽象出未知的不能操作；此外它本质上还是串行化的操作，总体来看使用for循环会将行为和方法混为一谈。另一种办法是使用内部迭代完成，properties.stream()该方法返回一个Stream而不是迭代器。使用内部迭代进行计算long count2 = properties.stream() .filter(p -&gt; p.sales &gt; 1000) .count();上述代码是通过Stream API完成的，我们可以把它理解为2个步骤：找出所有销量大于1000的店铺计算出店铺个数为了找出销量大于1000的店铺，需要先做一次过滤：filter，你可以看看这个方法的入参就是前面讲到的Predicate断言型函数式接口，测试一个函数完成后，返回值为boolean。由于Stream API的风格，我们没有改变集合的内容，而是描述了Stream的内容，最终调用count()方法计算出Stream里包含了多少个过滤之后的对象，返回值为long。创建Stream你已经知道Java8种在Collection接口添加了Stream方法，可以将任何集合转换成一个Stream。如果你操作的是一个数组可以使用Stream.of(1, 2, 3)方法将它转换为一个流。也许有人知道JDK7中添加了一些类库如Files.readAllLines(Paths.get(“/home/biezhi/a.txt”))这样的读取文件行方法。List作为Collection的子类拥有转换流的方法，那么我们读取这个文本文件到一个字符串变量中将变得更简洁：String content = Files.readAllLines(Paths.get(“/home/biezhi/a.txt”)).stream() .collect(Collectors.joining(“\\n”));这里的collect是后面要讲解的收集器，对Stream进行了处理后得到一个文本文件的内容。JDK8也为我们提供了一些便捷的Stream相关类库:{% image /static/img/article/java8-stream-class.png 320 500 java8提供的Stream类库 %}创建一个流是很简单的，下面我们试试用创建好的Stream做一些操作吧。流操作java.util.stream.Stream中定义了许多流操作的方法，为了更好的理解Stream API掌握它常用的操作非常重要。流的操作其实可以分为两类：处理操作、聚合操作。处理操作：诸如filter、map等处理操作将Stream一层一层的进行抽离，返回一个流给下一层使用。聚合操作：从最后一次流中生成一个结果给调用方，foreach只做处理不做返回。filterfilter看名字也知道是过滤的意思，我们通常在筛选数据的时候用到，频率非常高。filter方法的参数是Predicate&lt;T&gt; predicate即一个从T到boolean的函数。{% image /static/img/article/java8-filter.png 300 200 %}筛选出距离我在1000米内的店铺properties.stream() .filter(p -&gt; p.distance &lt; 1000)筛选出名称大于5个字的店铺properties.stream() .filter(p -&gt; p.name.length() &gt; 5);map有时候我们需要将流中处理的数据类型进行转换，这时候就可以使用map方法来完成，将流中的值转换为一个新的流。{% image /static/img/article/java8-map.png 300 200 %}列出所有店铺的名称properties.stream() .map(p -&gt; p.name);传给map的lambda表达式接收一个Property类型的参数，返回一个String。参数和返回值不必属于同一种类型，但是lambda表达式必须是Function接口的一个实例。flatMap有时候我们会遇到提取子流的操作，这种情况用的不多但是遇到flatMap将变得更容易处理。{% image /static/img/article/java8-flatmap.png 300 200 %}例如我们有一个List&lt;List&lt;String&gt;&gt;结构的数据：List&lt;List&lt;String&gt;&gt; lists = new ArrayList&lt;&gt;(); lists.add(Arrays.asList(“apple”, “click”)); lists.add(Arrays.asList(“boss”, “dig”, “qq”, “vivo”)); lists.add(Arrays.asList(“c#”, “biezhi”));要做的操作是获取这些数据中长度大于2的单词个数lists.stream() .flatMap(Collection::stream) .filter(str -&gt; str.length() &gt; 2) .count();在不使用flatMap前你可能需要做2次for循环。这里调用了List的stream方法将每个列表转换成Stream对象，其他的就和之前的操作一样。max和minStream中常用的操作之一是求最大值和最小值，Stream API 中的max和min操作足以解决这一问题。我们需要筛选出价格最低的店铺:Property property = properties.stream() .max(Comparator.comparingInt(p -&gt; p.priceLevel)) .get();查找Stream中的最大或最小元素，首先要考虑的是用什么作为排序的指标。以查找价格最低的店铺为例，排序的指标就是店铺的价格等级。为了让Stream对象按照价格等级进行排序，需要传给它一个Comparator对象。Java8提供了一个新的静态方法comparingInt，使用它可以方便地实现一个比较器。放在以前，我们需要比较两个对象的某项属性的值，现在只需要提供一个存取方法就够了。收集结果通常我们处理完流之后想查看一下结果，比如获取总数，转换结果，在前面的示例中你发现调用了filter、map之后没有下文了，后续的操作应该调用Stream中的collect方法完成。获取距离我最近的2个店铺List&lt;Property&gt; properties = properties.stream() .sorted(Comparator.comparingInt(x -&gt; x.distance)) .limit(2) .collect(Collectors.toList());获取所有店铺的名称List&lt;String&gt; names = properties.stream() .map(p -&gt; p.name) .collect(Collectors.toList());获取每个店铺的价格等级Map&lt;String, Integer&gt; map = properties.stream() .collect(Collectors.toMap(Property::getName, Property::getPriceLevel));所有价格等级的店铺列表Map&lt;Integer, List&lt;Property&gt;&gt; priceMap = properties.stream() .collect(Collectors.groupingBy(Property::getPriceLevel));并行数据处理并行和并发并发是两个任务共享时间段，并行则是两个任务在同一时间发生，比如运行在多核CPU上。如果一个程序要运行两个任务，并且只有一个CPU给它们分配了不同的时间片，那么这就是并发，而不是并行。并行化是指为缩短任务执行时间，将一个任务分解成几部分，然后并行执行。这和顺序执行的任务量是一样的，区别就像用更多的马来拉车，花费的时间自然减少了。实际上，和顺序执行相比，并行化执行任务时，CPU承载的工作量更大。数据并行化是指将数据分成块，为每块数据分配单独的处理单元。还是拿马拉车那个例子打比方，就像从车里取出一些货物，放到另一辆车上，两辆马车都沿着同样的路径到达目的地。当需要在大量数据上执行同样的操作时，数据并行化很管用。它将问题分解为可在多块数据上求解的形式，然后对每块数据执行运算，最后将各数据块上得到的结果汇总，从而获得最终答案。人们经常拿任务并行化和数据并行化做比较，在任务并行化中，线程不同，工作各异。我们最常遇到的JavaEE应用容器便是任务并行化的例子之一，每个线程不光可以为不同用户服务，还可以为同一个用户执行不同的任务，比如登录或往购物车添加商品。Stream并行流流使得计算变得容易，它的操作也非常简单，但你需要遵守一些约定。默认情况下我们使用集合的stream方法创建的是一个串行流，你有两种办法让他变成并行流。调用Stream对象的parallel方法创建流的时候调用parallelStream而不是stream方法我们来用具体的例子来解释串行和并行流串行化计算筛选出价格等级小于4，按照距离排序的2个店铺名properties.stream() .filter(p -&gt; p.priceLevel &lt; 4) .sorted(Comparator.comparingInt(Property::getDistance)) .map(Property::getName) .limit(2) .collect(Collectors.toList());调用 parallelStream 方法即能并行处理properties.parallelStream() .filter(p -&gt; p.priceLevel &lt; 4) .sorted(Comparator.comparingInt(Property::getDistance)) .map(Property::getName) .limit(2) .collect(Collectors.toList());读到这里，大家的第一反应可能是立即将手头代码中的stream方法替换为parallelStream方法，因为这样做简直太简单了！先别忙，为了将硬件物尽其用，利用好并行化非常重要，但流类库提供的数据并行化只是其中的一种形式。我们先要问自己一个问题：并行化运行基于流的代码是否比串行化运行更快？这不是一个简单的问题。回到前面的例子，哪种方式花的时间更多取决于串行或并行化运行时的环境。&lt;/div&gt;","categories":[],"tags":[]}]}